{"version":3,"sources":["../src/constants.ts","../src/editor/lib/color/utils.ts","../src/editor/lib/point.ts","../src/editor/lib/bezier-curve.ts","../src/editor/lib/component-curve.ts","../src/editor/lib/color-scale/utils.ts","../src/editor/lib/color-alias.ts","../src/editor/lib/utils.color-suite.ts","../src/editor/lib/utils.tailwind.ts","../src/plugin.tailwindcss.ts"],"sourcesContent":["import { ColorSuiteConfig } from './types';\r\nexport const EDITOR_APP_MOUNT_ID = '__cs-app'\r\n\r\nexport const COLOR_SUITE_ID = '@tailwindcss-color-suite'\r\nexport const COLOR_SUITE_PATH = `/${COLOR_SUITE_ID}`\r\n\r\n// Color config\r\nexport const COLOR_CONFIG_ID = `virtual:color-suite/config/colors`\r\nexport const PREFIXED_COLOR_CONFIG_ID = '\\0'+COLOR_CONFIG_ID\r\n\r\n// Resolved colors\r\nexport const RESOLVED_COLORS_ID = `virtual:color-suite/colors`\r\nexport const PREFIXED_RESOLVED_COLORS_ID = '\\0'+RESOLVED_COLORS_ID\r\n\r\n// Settings config\r\nexport const SETTINGS_CONFIG_ID = `virtual:color-suite/config/settings`\r\nexport const PREFIXED_SETTINGS_CONFIG_ID = '\\0'+SETTINGS_CONFIG_ID\r\n\r\n// Server end points for mutations on config\r\nexport const COLOR_CREATE_PATH = `/${COLOR_SUITE_ID}/color/create`\r\nexport const COLOR_UPDATE_PATH = `/${COLOR_SUITE_ID}/color/update`\r\nexport const COLOR_UPDATE_ALL_PATH = `/${COLOR_SUITE_ID}/color/updateAll`\r\nexport const COLOR_DELETE_PATH = `/${COLOR_SUITE_ID}/color/delete`\r\n\r\nexport const SETTINGS_UPDATE_PATH = `/${COLOR_SUITE_ID}/settings/update`\r\n\r\n// HotUpdate event\r\nexport const SETTINGS_UPDATED_EVENT = `${COLOR_SUITE_ID}:config-updated`\r\n\r\n// Default config file\r\nexport const DEFAULT_COLOR_CONFIG:ColorSuiteConfig = {\r\n\tcolors: {},\r\n\tsettings: {\r\n\t\topen_button: true,\r\n\t\tfloat_panel: false,\r\n\t\tinclude_current: true,\r\n\t\tinclude_transparent: true,\r\n\t\tinclude_inherit: true\r\n\t}\r\n}","import { ColorHEX, ColorHSV, ColorHSVA, ColorRGB, ColorRGBA } from './types'\r\n\r\nexport function isRGBColor(color:any):color is ColorRGB {\r\n\treturn typeof color == \"object\" && color.r != undefined && color.a == undefined\r\n}\r\nexport function isRGBAColor(color:any):color is ColorRGBA {\r\n\treturn typeof color == \"object\" && color.r != undefined && color.a != undefined\r\n}\r\nexport function isHSVColor(color:any):color is ColorHSV {\r\n\treturn typeof color == \"object\" && color.h != undefined && color.a == undefined\r\n}\r\nexport function isHSVAColor(color:any):color is ColorHSVA {\r\n\treturn typeof color == \"object\" && color.h != undefined && color.a != undefined\r\n}\r\nexport function isHexColor(color:any):color is ColorHEX {\r\n\treturn typeof color == 'string' && color[0] == '#' && (color.length == 7 || color.length == 9)\r\n}\r\n\r\nexport function rgbToHSV({ r, g, b }:ColorRGB):ColorHSV {\r\n\tr /= 255, g /= 255, b /= 255\r\n\r\n\tlet max = Math.max(r, g, b), min = Math.min(r, g, b)\r\n\tlet h = 0, s = 0, v = max\r\n\r\n\tlet d = max - min\r\n\ts = max == 0 ? 0 : d / max\r\n\r\n\tif(max == min) {\r\n\t\t\th = 0; // achromatic\r\n\t} else {\r\n\t\t\tswitch(max) {\r\n\t\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\r\n\t\t\t\t\tcase g: h = (b - r) / d + 2; break;\r\n\t\t\t\t\tcase b: h = (r - g) / d + 4; break;\r\n\t\t\t}\r\n\t\t\th /= 6\r\n\t}\r\n\r\n\th *= 360, s *= 100, v *= 100\r\n\treturn { h, s, v }\r\n}\r\n\r\nexport function rgbaToHSVA({ r, g, b, a = 100 }:ColorRGBA):ColorHSVA {\r\n\treturn { ...rgbToHSV({ r, g, b }), a }\r\n}\r\n\r\nexport function hsvToRGB({ h, s, v }:ColorHSV):ColorRGB {\r\n\th /= 360, s /= 100, v /= 100\r\n\r\n\tlet r = 0, g = 0, b = 0;\r\n\r\n\tlet i = Math.floor(h * 6);\r\n\tlet f = h * 6 - i;\r\n\tlet p = v * (1 - s);\r\n\tlet q = v * (1 - f * s);\r\n\tlet t = v * (1 - (1 - f) * s);\r\n\r\n\tswitch(i % 6){\r\n\t\t\tcase 0: r = v, g = t, b = p; break;\r\n\t\t\tcase 1: r = q, g = v, b = p; break;\r\n\t\t\tcase 2: r = p, g = v, b = t; break;\r\n\t\t\tcase 3: r = p, g = q, b = v; break;\r\n\t\t\tcase 4: r = t, g = p, b = v; break;\r\n\t\t\tcase 5: r = v, g = p, b = q; break;\r\n\t}\r\n\r\n\tr = Math.round(r * 255), g = Math.round(g * 255), b = Math.round(b * 255)\r\n\treturn { r, g, b }\r\n}\r\n\r\nexport function hsvaToRGBA({ h, s, v, a = 100 }:ColorHSVA):ColorRGBA {\r\n\treturn { ...hsvToRGB({ h, s, v }), a }\r\n}\r\n\r\nfunction decToHex(decimal:number):string {\r\n\treturn Math.round(decimal).toString(16).padStart(2, '0')\r\n}\r\n\r\nfunction hexToDec(hex:string):number {\r\n\treturn parseInt(hex, 16)\r\n}\r\n\r\nexport function rgbToHex({ r, g, b }:ColorRGB):ColorHEX {\r\n\treturn `#${ decToHex(r) }${ decToHex(g) }${ decToHex(b) }`\r\n}\r\n\r\nexport function rgbaToHex({ r, g, b, a = 100 }:ColorRGBA):ColorHEX {\r\n\treturn rgbToHex({r, g, b }) + (a == 100 ? '' : decToHex(a * 2.55))\r\n}\r\n\r\nexport function hexToRGB(hex:ColorHEX):ColorRGB {\r\n\tconst [r, g, b] = (hex.slice(1).match(/.{1,2}/g) || []).map(hexToDec)\r\n\treturn {\r\n\t\tr, g, b\r\n\t}\r\n}\r\n\r\nexport function hexToRGBA(hex:ColorHEX):ColorRGBA {\r\n\tconst [r, g, b, a] = (hex.slice(1).match(/.{1,2}/g) || []).map(hexToDec)\r\n\treturn {\r\n\t\t...{ a: 100 }, // Make sure we always have alpha\r\n\t\tr, g, b, a\r\n\t}\r\n}\r\n\r\nexport function hsvaToHex(hsva:ColorHSVA):ColorHEX {\r\n\treturn rgbaToHex(hsvaToRGBA(hsva))\r\n}\r\n\r\nexport function hexToHSVA(hex:ColorHEX):ColorHSVA {\r\n\treturn rgbaToHSVA(hexToRGBA(hex))\r\n}\r\n\r\nexport function isDarkColor(hex:ColorHEX) {\r\n\tconst { r, g, b } = hexToRGBA(hex)\r\n\r\n\tlet yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000\r\n\treturn (yiq >= 128) ? false : true\r\n}","export class Point {\r\n\tx:number = 0\r\n\ty:number = 0\r\n\r\n\tconstructor()\r\n\tconstructor(x:number, y:number)\r\n\tconstructor(x_or_point_like:Partial<{x:number, y:number}>)\r\n\tconstructor(x_or_point_like?:number|Partial<{x:number, y:number}>, y?:number) {\r\n\t\tif (typeof x_or_point_like == 'object') {\r\n\t\t\tconst { x, y } = x_or_point_like\r\n\t\t\tif (x) this.x = x\r\n\t\t\tif (y) this.y = y\r\n\t\t} else if(typeof x_or_point_like == 'number') {\r\n\t\t\tthis.x = x_or_point_like\r\n\t\t\tif (y) this.y = y\r\n\t\t}\r\n\t}\r\n\r\n\ttoString() {\r\n\t\treturn `${this.x * 100},${this.y * 100}`\r\n\t}\r\n\r\n\ttoArray() {\r\n\t\treturn [this.x, this.y]\r\n\t}\r\n\r\n\tlength() {\r\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y)\r\n\t}\r\n\r\n\tstatic normalize(point:Point) {\r\n\t\tlet length = point.length()\r\n\t\tif (length == 0) return new Point()\r\n\t\treturn new Point(point.x / length, point.y / length)\r\n\t}\r\n\r\n\tstatic add(p1:Point, p2:Point) {\r\n\t\treturn new Point(p1.x + p2.x, p1.y + p2.y)\r\n\t}\r\n\r\n\tstatic subtract(p1:Point, p2:Point) {\r\n\t\treturn new Point(p1.x - p2.x, p1.y - p2.y)\r\n\t}\r\n\r\n\tstatic multiply(p1:Point, p2:Point) {\r\n\t\treturn new Point(p1.x * p2.x, p1.y * p2.y)\r\n\t}\r\n\r\n\tstatic divide(p1:Point, p2:Point) {\r\n\t\treturn new Point(p1.x / p2.x, p1.y / p2.y)\r\n\t}\r\n\r\n\tstatic min(min:number, p:Point) {\r\n\t\treturn new Point(Math.min(min, p.x), Math.min(min, p.y))\r\n\t}\r\n\r\n\tstatic max(max:number, p:Point) {\r\n\t\treturn new Point(Math.max(max, p.x), Math.max(max, p.y))\r\n\t}\r\n}","import { Point } from './point';\r\n\r\nconst EPSILON = 0.000001\r\nconst TAU = Math.PI * 2\r\nfunction approximately(a:number,b:number,precision?:number) {\r\n\treturn Math.abs(a-b) <= (precision || EPSILON)\r\n}\r\nfunction cuberoot(v:number) {\r\n\treturn v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);\r\n}\r\n\r\nfunction getRoots(pa:number, pb:number, pc:number, pd:number) {\r\n\tvar reduce = function(t) {\r\n\t\treturn 0 <= t && t <= 1;\r\n\t}\r\n\r\n\tvar d = -pa + 3 * pb - 3 * pc + pd,\r\n\t\t\ta = 3 * pa - 6 * pb + 3 * pc,\r\n\t\t\tb = -3 * pa + 3 * pb,\r\n\t\t\tc = pa;\r\n\r\n\tif (approximately(d, 0)) {\r\n\t\t// this is not a cubic curve.\r\n\t\tif (approximately(a, 0)) {\r\n\t\t\t// in fact, this is not a quadratic curve either.\r\n\t\t\tif (approximately(b, 0)) {\r\n\t\t\t\t// in fact in fact, there are no solutions.\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t\t// linear solution:\r\n\t\t\treturn [-c / b].filter(reduce);\r\n\t\t}\r\n\t\t// quadratic solution:\r\n\t\tvar q = Math.sqrt(b * b - 4 * a * c),\r\n\t\t\ta2 = 2 * a;\r\n\t\treturn [(q - b) / a2, (-b - q) / a2].filter(reduce);\r\n\t}\r\n\r\n\t// at this point, we know we need a cubic solution:\r\n\r\n\ta /= d;\r\n\tb /= d;\r\n\tc /= d;\r\n\r\n\tvar p = (3 * b - a * a) / 3,\r\n\t\tp3 = p / 3,\r\n\t\tq = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\r\n\t\tq2 = q / 2,\r\n\t\tdiscriminant = q2 * q2 + p3 * p3 * p3,\r\n\t\tu1,\r\n\t\tv1,\r\n\t\tx1,\r\n\t\tx2,\r\n\t\tx3;\r\n\tif (discriminant < 0) { // Discriminant is negative, there are 3 roots\r\n\t\tvar mp3 = -p / 3,\r\n\t\t\tmp33 = mp3 * mp3 * mp3,\r\n\t\t\tr = Math.sqrt(mp33),\r\n\t\t\tt = -q / (2 * r),\r\n\t\t\tcosphi = t < -1 ? -1 : t > 1 ? 1 : t,\r\n\t\t\tphi = Math.acos(cosphi),\r\n\t\t\tcrtr = cuberoot(r),\r\n\t\t\tt1 = 2 * crtr;\r\n\t\tx1 = t1 * Math.cos(phi / 3) - a / 3;\r\n\t\tx2 = t1 * Math.cos((phi + TAU) / 3) - a / 3;\r\n\t\tx3 = t1 * Math.cos((phi + 2 * TAU) / 3) - a / 3;\r\n\t\treturn [x1, x2, x3].filter(reduce);\r\n\t} else if (discriminant === 0 && p + q != 0) { // Discriminant is zero, there are two roots\r\n\t\tu1 = q2 < 0 ? cuberoot(-q2) : -cuberoot(q2);\r\n\t\tx1 = 2 * u1 - a / 3;\r\n\t\tx2 = -u1 - a / 3;\r\n\t\treturn [x1, x2].filter(reduce);\r\n\t} else { // Discriminant is positive, there is one root\r\n\t\tvar sd = Math.sqrt(discriminant);\r\n\t\tu1 = cuberoot(-q2 + sd);\r\n\t\tv1 = cuberoot(q2 + sd);\r\n\t\treturn [u1 - v1 - a / 3].filter(reduce);\r\n\t}\r\n}\r\n\r\nexport class BezierCurve {\r\n\tP1:Point = new Point(0, 0)\r\n\tP2:Point = new Point(0.5, 0.5)\r\n\tP3:Point = new Point(0.5, 0.5)\r\n\tP4:Point = new Point(1, 1)\r\n\r\n\tconstructor(points:[Point, Point, Point, Point]) {\r\n\t\tthis.P1 = points[0]\r\n\t\tthis.P2 = points[1]\r\n\t\tthis.P3 = points[2]\r\n\t\tthis.P4 = points[3]\r\n\t}\r\n\r\n\tsample(t:number) {\r\n\t\tconst inverse_t = 1-t;\r\n\t\tconst a = inverse_t * inverse_t * inverse_t\r\n\t\tconst b = 3 * t * inverse_t * inverse_t\r\n\t\tconst c = 3 * t * t * inverse_t\r\n\t\tconst d = t * t * t\r\n\r\n\t\treturn new Point(\r\n\t\t\tthis.P1.x * a + this.P2.x * b + this.P3.x * c + this.P4.x * d,\r\n\t\t\tthis.P1.y * a + this.P2.y * b + this.P3.y * c + this.P4.y * d\r\n\t\t)\r\n\t}\r\n\r\n\tgetTForY(y:number) {\r\n\t\tlet roots = getRoots(this.P1.y - y, this.P2.y - y, this.P3.y - y, this.P4.y - y)\r\n\t\treturn roots[0]\r\n\t}\r\n\r\n\tgetXForY(y:number) {\r\n\t\tlet t:number\r\n\r\n\t\tif (y == 0 || y == 1) t = y\r\n\t\telse t = this.getTForY(y)\r\n\r\n\t\treturn this.sample(t).x\r\n\t}\r\n}","import { CSComponentCurve } from '../../types'\r\nimport { Point } from './point'\r\nimport { BezierCurve } from './bezier-curve'\r\n\r\nexport function componentCurveToBezierPoints(curve:CSComponentCurve):{start:[Point, Point, Point, Point], end:[Point, Point, Point, Point]} {\r\n\tlet start = new Point(curve.start, 0)\r\n\tlet mid = new Point(curve.mid, 0.5)\r\n\tlet end = new Point(curve.end, 1)\r\n\r\n\tlet C1 = Point.max(0, Point.min(1, Point.add(start, new Point(curve.controls[0]))))\r\n\tlet C2 = Point.max(0, Point.min(1, Point.add(mid, new Point(curve.controls[1]))))\r\n\tlet C3 = Point.max(0, Point.min(1, Point.add(mid, new Point(curve.controls[2]))))\r\n\tlet C4 = Point.max(0, Point.min(1, Point.add(end, new Point(curve.controls[3]))))\r\n\r\n\treturn {\r\n\t\tstart: [start, C1, C2, mid],\r\n\t\tend: [mid, C3, C4, end]\r\n\t}\r\n}\r\n\r\nexport function sampleComponentCurve(component:CSComponentCurve, y:number, max:number = 100) {\r\n\tlet { start, end } = componentCurveToBezierPoints(component)\r\n\tlet start_bezier = new BezierCurve(start)\r\n\tlet end_bezier = new BezierCurve(end)\r\n\r\n\tif (y < 0.5) return start_bezier.getXForY(y) * max\r\n\tif (y == 0.5) return start[3].x * max\r\n\treturn end_bezier.getXForY(y) * max\r\n}","import { CSColorScale, CSColor } from '../../../types';\r\nimport { ColorHSV, ColorHSVA, ColorHEX, ColorRGBA } from '../color/types'\r\nimport { hsvaToHex, hsvaToRGBA } from '../color/utils'\r\nimport { sampleComponentCurve } from '../component-curve'\r\n\r\nexport function colorScaleTokens(color_scale:CSColorScale) {\r\n\tlet tokens:string[] = []\r\n\r\n\tfor (let i = 0; i < color_scale.steps; i++) {\r\n\t\tlet step = i / (color_scale.steps-1)\r\n\t\tlet interval = Math.round(step * color_scale.start + (1-step) * color_scale.end)\r\n\r\n\t\ttokens.push(interval.toString())\r\n\t}\r\n\treturn tokens\r\n}\r\n\r\nexport function samplePanelColorScale(color_scale:CSColorScale, y:number):ColorHSV {\r\n\tlet hue = (sampleComponentCurve(color_scale.hue_curve , y, 360) + (color_scale.hue_offset ?? 0)) % 360\r\n\tlet saturation = sampleComponentCurve(color_scale.saturation_curve, y)\r\n\tlet value = sampleComponentCurve(color_scale.value_curve, y)\r\n\r\n\treturn { h: hue, s: saturation, v: value }\r\n}\r\n\r\nexport function colorScaleHSVAValues(color_scale:CSColorScale):{[interval:number]:ColorHSVA} {\r\n\tlet scale = {}\r\n\r\n\tfor (let i = 0; i < color_scale.steps; i++) {\r\n\t\tlet step = i / (color_scale.steps-1)\r\n\t\tlet interval = Math.round(step * color_scale.start + (1-step) * color_scale.end)\r\n\r\n\t\tscale[interval] = { ...samplePanelColorScale(color_scale, 1-step), a: 100 }\r\n\t}\r\n\r\n\treturn scale\r\n}\r\n\r\nexport function colorScaleRGBAValues(color_scale:CSColorScale):{[interval:number]:ColorRGBA} {\r\n\tlet scale = {}\r\n\r\n\tfor (let i = 0; i < color_scale.steps; i++) {\r\n\t\tlet step = i / (color_scale.steps-1)\r\n\t\tlet interval = Math.round(step * color_scale.start + (1-step) * color_scale.end)\r\n\r\n\t\tscale[interval] = hsvaToRGBA(samplePanelColorScale(color_scale, 1-step) as ColorHSVA)\r\n\t}\r\n\r\n\treturn scale\r\n}\r\n\r\nexport function colorScaleHexValues(color_scale:CSColorScale):{[interval:number]:ColorHEX} {\r\n\tlet scale = {}\r\n\r\n\tfor (let i = 0; i < color_scale.steps; i++) {\r\n\t\tlet step = i / (color_scale.steps-1)\r\n\t\tlet interval = Math.round(step * color_scale.start + (1-step) * color_scale.end)\r\n\r\n\t\tscale[interval] = hsvaToHex(samplePanelColorScale(color_scale, 1-step) as ColorHSVA)\r\n\t}\r\n\r\n\treturn scale\r\n}\r\n\r\nexport function colorScaleSteps(color_scale:CSColorScale, scale_values:ReturnType<typeof colorScaleHexValues>) {\r\n\tlet steps:{step:number, color:string}[] = []\r\n\r\n\tfor (let i = 0; i < color_scale.steps; i++) {\r\n\t\tlet step = i / (color_scale.steps-1)\r\n\t\tlet interval = Math.round(step * color_scale.start + (1-step) * color_scale.end)\r\n\r\n\r\n\t\tsteps.push({ step, color: scale_values[interval] })\r\n\t}\r\n\r\n\treturn steps\r\n}","import { CSColorAlias, CSColor, CSColorAliasResolutionError, ColorSuiteColors } from '../../types'\r\nimport { isColorSolid, isColorAlias, isColorScale, isColorAliasResolutionError } from './utils.color-suite'\r\nimport { colorScaleHSVAValues } from './color-scale/utils'\r\n\r\nconst tokens_looked_up:string[] = []\r\nexport function resolveAlias(alias:CSColorAlias, colors:ColorSuiteColors, deep:boolean = false):CSColor|CSColorAliasResolutionError {\r\n\tif (!deep) tokens_looked_up.length = 0 // reset tokens looked up\r\n\r\n\tlet alias_keys:string[] = alias.split('.')\r\n\r\n\t// Shallow look up\r\n\tlet token = alias_keys.shift() // the first item in the array will be the root level color token\r\n\tif (!token) throw new Error('Unable to resolve alias: the alias does not contain a valid token reference')\r\n\r\n\tif (tokens_looked_up.includes(token)) return { message: 'Unable to resolve alias: cyclic token reference encountered' }\r\n\telse tokens_looked_up.push(token)\r\n\r\n\tlet resolved_color:CSColor|CSColorAliasResolutionError = colors[token]\r\n\tif (!resolved_color) return { message: `Unable to resolve alias: ${token} does not exist in the colors config` }\r\n\r\n\tif (isColorAlias(resolved_color)) resolved_color = resolveAlias(resolved_color, colors, true) // We resolved to an alias, which itself needs to be resolved\r\n\tif (isColorAliasResolutionError(resolved_color)) return resolved_color // If the alias resolved an error let's just pass it along\r\n\r\n\t// Deep look up\r\n\twhile (alias_keys.length) { // We have to drill down further\r\n\t\tlet next_token = alias_keys.shift()\r\n\t\tif (!next_token) throw new Error(`Unable to resolve alias: improperly formatted alias`)\r\n\r\n\t\tif (isColorAliasResolutionError(resolved_color)) return resolved_color\r\n\t\tif (isColorSolid(resolved_color)) return { message: `Unable to resolve alias: ${alias} does not exist in the colors config` }\r\n\t\tif (isColorScale(resolved_color)) {\r\n\t\t\tlet hsva_scale = colorScaleHSVAValues(resolved_color)\r\n\t\t\tresolved_color = hsva_scale[next_token] // If it exists in the scale, resolve to it or resolve an alias resolution error message\r\n\t\t\tif (!resolved_color) return { message: `Unable to resolve alias: ${token} does not exist in the color scale` }\r\n\t\t}\r\n\t}\r\n\r\n\treturn resolved_color\r\n\r\n}","import { CSComponentCurve, ColorSuiteColors, CSColorScale, CSColor, CSColorAlias, CSColorSolid, CSColorAliasResolutionError, Point as IPoint } from '../../types'\r\nimport { isHSVAColor, hsvaToRGBA } from './color/utils'\r\nimport { Point } from './point'\r\nimport { colorScaleRGBAValues } from './color-scale/utils'\r\nimport { resolveAlias } from './color-alias'\r\n\r\nexport function isColorSolid(color:CSColor):color is CSColorSolid {\r\n\treturn isHSVAColor(color)\r\n}\r\nexport function isColorScale(color:CSColor):color is CSColorScale {\r\n\treturn typeof color == \"object\" && (color as any).hue_curve != undefined && (color as any).start != undefined\r\n}\r\n\r\nexport function isColorAlias(color:CSColor):color is CSColorAlias {\r\n\treturn typeof color == \"string\"\r\n}\r\n\r\nexport function isColorAliasResolutionError(object:any):object is CSColorAliasResolutionError {\r\n\treturn typeof object == \"object\" && !!object.message\r\n}\r\n\r\nexport function convertPoints(curve:CSComponentCurve) {\r\n\tfor (let i in curve.controls) {\r\n\t\tif (!(curve.controls[i] instanceof Point))\r\n\t\t{\r\n\t\t\tcurve.controls[i] = new Point(curve.controls[i])\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function hydrateColorConfig(colors:ColorSuiteColors) {\r\n\tfor (let [_, value] of Object.entries(colors)) {\r\n\t\tif (isColorScale(value)) {\r\n\t\t\tconvertPoints(value.hue_curve)\r\n\t\t\tconvertPoints(value.saturation_curve)\r\n\t\t\tconvertPoints(value.value_curve)\r\n\t\t}\r\n\t}\r\n\treturn colors\r\n}\r\n\r\nexport function convertPointBack(curve:CSComponentCurve) {\r\n\tconst controls = new Array<IPoint>(4)\r\n\tfor (let i in curve.controls) {\r\n\t\tif ((curve.controls[i] instanceof Point)) {\r\n\t\t\tcontrols[i] = { x: curve.controls[i].x, y: curve.controls[i].y}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcontrols[i] = curve.controls[i]\r\n\t\t}\r\n\t}\r\n\tcurve.controls = controls as [IPoint, IPoint, IPoint, IPoint]\r\n}\r\n\r\nexport function dehydrateColorConfig(colors:ColorSuiteColors) {\r\n\tfor (let [_, value] of Object.entries(colors)) {\r\n\t\tif (isColorScale(value)) {\r\n\t\t\tconvertPointBack(value.hue_curve)\r\n\t\t\tconvertPointBack(value.saturation_curve)\r\n\t\t\tconvertPointBack(value.value_curve)\r\n\t\t}\r\n\t}\r\n\treturn colors\r\n}\r\n\r\nlet color_suite_sheet:CSSStyleSheet\r\nfunction getColorSuiteSheet() {\r\n\tif (!color_suite_sheet) {\r\n\t\tconst style = document.createElement(\"style\")\r\n\t\tstyle.id = 'color_suite_variables'\r\n\t\tdocument.head.appendChild(style)\r\n\r\n\t\tlet sheet = style.sheet\r\n\t\tif (!sheet) throw new Error('Color Suite stylesheet could not be created.')\r\n\r\n\t\tcolor_suite_sheet = sheet\r\n\t}\r\n\r\n\treturn color_suite_sheet\r\n}\r\n\r\nconst root_variable_sheet_indexes = new Map<string, number>()\r\nexport function setRootVariable(token:string, value:string) {\r\n\tconst sheet = getColorSuiteSheet()\r\n\tlet existing_index:number|undefined\r\n\tif (root_variable_sheet_indexes.has(token)) {\r\n\t\texisting_index = root_variable_sheet_indexes.get(token)\r\n\t\tif (existing_index) {\r\n\t\t\tsheet.deleteRule(existing_index)\r\n\t\t\troot_variable_sheet_indexes.set(token, sheet.insertRule(`:root{ --${ token }: ${ value } }`, existing_index))\r\n\t\t}\r\n\t} else {\r\n\t\tlet new_index = sheet.insertRule(`:root{ --${ token }: ${ value } }`, sheet.rules.length)\r\n\t\troot_variable_sheet_indexes.set(token, new_index)\r\n\t}\r\n}\r\n\r\nexport function updateRootVariables(token:string, color:CSColor, colors:ColorSuiteColors) {\r\n\tlet resolved_color = isColorAlias(color) ? resolveAlias(color, colors) : color\r\n\tif (isColorAliasResolutionError(resolved_color)) return\r\n\r\n\tif (isColorSolid(resolved_color)) {\r\n\t\tlet {r,g,b} = hsvaToRGBA(resolved_color)\r\n\t\tlet value = isColorAlias(color) ? `var(--color-${ color.replace('.', '-') }, ${[r,g,b].join(',')})` : [r,g,b].join(',')\r\n\t\tsetRootVariable(`color-${token}`, value)\r\n\t}\r\n\tif (isColorScale(resolved_color)) {\r\n\t\tlet scale_values = colorScaleRGBAValues(resolved_color)\r\n\t\tfor (let [modifier, { r, g, b }] of Object.entries(scale_values)) {\r\n\t\t\tlet value = isColorAlias(color) ? `var(--color-${ color.replace('.', '-') }-${ modifier }, ${[r,g,b].join(',')})` : [r,g,b].join(',')\r\n\t\t\tsetRootVariable(`color-${ token }-${ modifier }`, value)\r\n\t\t}\r\n\t}\r\n}","import { CSColor, ColorSuiteColors, TailwindColorValue, TailwindColorFunction } from '../../types';\r\nimport { isColorSolid, isColorAlias, isColorAliasResolutionError, isColorScale } from './utils.color-suite'\r\nimport { resolveAlias } from './color-alias'\r\nimport { colorScaleTokens, colorScaleRGBAValues } from './color-scale/utils';\r\nimport { hsvaToRGBA } from './color/utils';\r\n\r\nexport function createTailwindColorFunction(name:string, default_value?:string):TailwindColorFunction {\r\n\treturn (options) => {\r\n\t\tlet css_variable = `var(--${ name }${ default_value ? `, ${ default_value}` : '' })`\r\n\t\tif (!options) return `rgb(${ css_variable })`\r\n\t\tif (options.opacityValue != undefined) return `rgba(${ css_variable }, ${ options.opacityValue })`\r\n\t\tif (options.opacityVariable != undefined) return `rgba(${ css_variable }, var(${ options.opacityVariable }))`\r\n\t\treturn `rgb(${ css_variable })`\r\n\t}\r\n}\r\n\r\nexport function colorToTailwind(token:string, color:CSColor, colors:ColorSuiteColors, use_rgba?:boolean):TailwindColorValue {\r\n\tlet resolved_color = isColorAlias(color) ? resolveAlias(color, colors) : color\r\n\tif (isColorAliasResolutionError(resolved_color)) {\r\n\t\tconsole.warn(`[Color Suite] ${ token } - ${ resolved_color.message }`) // If we failed to resolve the alias, warn the user and return black\r\n\t\treturn '#000'\r\n\t}\r\n\r\n\tif (isColorSolid(resolved_color)) {\r\n\t\tconst { r, g, b, a } = hsvaToRGBA(resolved_color)\r\n\t\tif (use_rgba) return a == 100 ? `rgb(${[r,g,b].join(',')})` : `rgba(${[r,g,b,a].join(',')})`\r\n\t\treturn createTailwindColorFunction(`color-${ token }`, [r,g,b].join(','))\r\n\t}\r\n\tif (isColorScale(resolved_color)) {\r\n\t\tlet tailwind_color_object:any = {}\r\n\t\tlet rgba_scale = colorScaleRGBAValues(resolved_color)\r\n\t\tfor (let [modifier, { r, g, b, a }] of Object.entries<any>(rgba_scale)) {\r\n\t\t\tif (use_rgba) tailwind_color_object[modifier] = a == 100 ? `rgb(${[r,g,b].join(',')})` : `rgba(${[r,g,b,a].join(',')})`\r\n\t\t\telse tailwind_color_object[modifier] = createTailwindColorFunction(`color-${ token }-${ modifier }`, [r,g,b].join(','))\r\n\t\t}\r\n\t\treturn tailwind_color_object\r\n\t}\r\n\r\n\treturn '#000'\r\n}","import { ColorSuiteConfig, TailwindColors } from './types'\r\nimport { DEFAULT_COLOR_CONFIG } from './constants'\r\nimport { colorToTailwind } from './editor/lib/utils.tailwind'\r\n\r\nexport function configToTailwindColors(color_config:ColorSuiteConfig, use_rgba?:boolean):TailwindColors {\r\n\tconst { include_current, include_transparent, include_inherit } = color_config.settings\r\n\r\n\tlet tailwind_color_config = {}\r\n\tfor (let [token, value] of Object.entries(color_config.colors)) {\r\n\t\ttailwind_color_config[token] = colorToTailwind(token, value, color_config.colors, use_rgba)\r\n\t}\r\n\r\n\tif (include_transparent) tailwind_color_config['transparent'] = 'transparent'\r\n\tif (include_current) tailwind_color_config['current'] = 'currentColor'\r\n\tif (include_inherit) tailwind_color_config['inherit'] = 'inherit'\r\n\r\n\treturn tailwind_color_config\r\n}\r\n\r\nexport function tailwindColors(color_config?:ColorSuiteConfig) {\r\n\tcolor_config = Object.assign({}, DEFAULT_COLOR_CONFIG, color_config)\r\n\treturn configToTailwindColors(color_config)\r\n}"],"mappings":"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","names":["y","t"]}